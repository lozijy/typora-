### 5.13

每日一题(难度较低)

![image-20220514213251733](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220514213251733.png)

双指针

```java
import static java.lang.Math.abs;
class Solution {
    public boolean oneEditAway(String first, String second) {
        int n = first.length();
        int m = second.length();
        int count = 0;
        int i = 0;
        //修改的情况
        if (n == m) {
            for (i = 0; i < n; i++) {
                if (first.charAt(i) != second.charAt(i)) {
                    count++;
                }
            }
            if (count >= 2) {
                return false;
            }else
                return true;
        }
        //删除或添加的情况
            if (abs(n - m) == 1) {
                int j = 0;

                while (i < n && j < m && count < 2) {
                    if (first.charAt(i) != second.charAt(j)) {
                        count++;
                        if (n > m) {
                            i++;
                        } else {
                            j++;
                        }
                    }else{
                    i++;
                    j++;
                    }
                }
                if (count >= 2) {
                    return false;
                } else {
                    return true;
                }
            }
        //其他情况下返回false
        return false;
    }
}
```

也可考虑使用动态规划

```java
class Solution {
    public boolean oneEditAway(String first, String second) {
        int m = first.length(), n = second.length();
        if (Math.abs(m - n) > 1) {
            return false;
        }

        if (m != n) {
            // dp[i][j]：表示first[0..i-1]和second[0..j-1]的最长公共子列的长度
            int[][] dp = new int[m + 1][n + 1];
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    if (first.charAt(i - 1) == second.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][	j], dp[i][j - 1]);
                    }
                }
            }
            return dp[m][n] == Math.min(m, n);
        } else {
            return canOneEdit(first, second);
        }
    }

    private boolean canOneEdit(String s1, String s2) {
        int count = 0;
        for (int i = 0, len = s1.length(); i < len; i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                ++count;
            }
            if (count > 1) {
                return false;
            }
        }
        return true;
    }
}

```

![image-20220515110142710](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515110142710.png)

### 5.14

11.盛最多水的容器(难度较低)

![image-20220514213958749](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220514213958749.png)

![image-20220514214015671](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220514214015671.png)

双指针

核心思想是贪心,尽可能让面积更大，面积的计算公式是底乘高，即

p*math.min(height[l],height[j]),拥有两个变量，我们让p线性减小的情况下对hmin贪心，即比较height[l]和height[r]，让更小的进行移动。

```java
class Solution {
    public int maxArea(int[] height) {
        int ans=0;
        int l=0;
        int r=height.length-1;
        while(l<=r){
            ans=Math.max(Math.min(height[l],height[r])*(r-l),ans);
            if(height[l]<=height[r]){
                l++;
            }else{
                r--;
            }
        }
        return ans;
    }
}
```



前缀和的简单应用

原数列

前缀和数列s[i]=a[1]+a[2]+...+a[i]

运用前缀和数列求一个区间的和时间复杂度和减小到o(1),

比如求a[l]+a[l+1]+...+a[r-1]+a[r],直接=s[r]-s[l-1]事件复杂度从o(n)减小到o(1)

代码

```java
public static int search(int []nums,int l,int r){
    int[] num2=new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j <= i; j++) {
            num2[i]+=nums[j];
        }
    }
    int cnt=0;
    cnt=num2[r-1]-num2[l-2];
    return cnt;
}
```







5.15

每日一题

最大三角形面积（几何算法）

s=1/2\*dmid*(hmax-hmin)

考虑使用贪心算法

保证hmax-hmin最大的情况下保证dmid最大

不考虑排序，不考虑递归，可以遍历，是一个二维数组，

算了放弃了。

算了，考虑dP算法，用dp\[i][0]表示不取这个点时的面积，dp\[i][1]取这个点时候的面积，和之前的不太一样，这里取点最多取三个，而且最前面的2个点无法构成三角形，且递推无法进行下去。



题解:

1.数学+枚举

三角形面积公式

![image-20220515110630388](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515110630388.png)

由于三个点是等价的(可互换),遍历时可以优化j从i+1开始，k从j+1开始

```java
class Solution {
    public double largestTriangleArea(int[][] points) {
        int n = points.length;
        double ret = 0.0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));
                }
            }
        }
        return ret;
    }

    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {
        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);
    }
}


```

2.凸包解法参考587.安装栅栏

Andrew扫描法

将凸包分为上凸壳和下凸壳

![image-20220515120053893](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515120053893.png)

1.将所有点按2个指标进行排序，先按x坐标升序排列，再按y坐标升序排列

2.用栈维护所有凸包上的点，或者说是凸包上的边，凸包起点元素会在栈中出现两次。

3.分别从前往后和从后往前处理排序好的所有点，来分别画出凸包的两半部分，根据画的是第一部分还是第二部分，维护站内元的处理稍稍不同。

a.画的是第一部分

- 栈内元素少于2个，说明第一条边未画出，直接将元素添加到栈中
- 元素不少于2个会考虑是否删掉栈顶的边，根据时针方向来决定是否删除
- ![image-20220515120545943](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515120545943.png)

模板：

```java
class Solution {
    int[] subtraction(int[] a, int[] b) { // 向量相减
        return new int[]{a[0] - b[0], a[1] - b[1]};
    }
    double cross(int[] a, int[] b) { // 叉乘
        return a[0] * b[1] - a[1] * b[0];
    }
    double getArea(int[] a, int[] b, int[] c) { // 向量 ab 转为 向量 ac 过程中扫过的面积
        return cross(subtraction(b, a), subtraction(c, a));
    }
    public int[][] outerTrees(int[][] trees) {
        //排序
        Arrays.sort(trees, (a, b)->{
            return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];
        });
        int n = trees.length, tp = 0;
        int[] stk = new int[n + 10];
        boolean[] vis = new boolean[n + 10];
        stk[++tp] = 0; // 不标记起点
        //维护栈
        for (int i = 1; i < n; i++) {
            int[] c = trees[i];
            //tp大于2
            while (tp >= 2) {
                int[] a = trees[stk[tp - 1]], b = trees[stk[tp]];
                if (getArea(a, b, c) > 0) vis[stk[tp--]] = false;
                else break;
            }
            //tp小于2直接加
            stk[++tp] = i;
            vis[i] = true;
        }
        int size = tp;
        for (int i = n - 1; i >= 0; i--) {
            if (vis[i]) continue;
            int[] c = trees[i];
            while (tp > size) {
                int[] a = trees[stk[tp - 1]], b = trees[stk[tp]];
                if (getArea(a, b, c) > 0) tp--;
                // vis[stk[tp--]] = false; // 非必须
                else break;
            }
            stk[++tp] = i;
            // vis[i] = true; // 非必须
        }
        int[][] ans = new int[tp - 1][2];
        for (int i = 1; i < tp; i++) ans[i - 1] = trees[stk[i]];
        return ans;
    }
}
```



5.16每日一题
![image-20220516115426741](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516115426741.png)

最近才学了二叉树的前序，中序，后序遍历，那就用中序遍历的方法找到后继节点。

习惯这种数组形式的node，其实和普通的node是一样的

第一次提交

```java
import java.util.Stack;

class Solution {
    public static TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur=root;
        TreeNode pre=null;
        if(root!=null){
            Stack<TreeNode> stack=new Stack<>();
            stack.push(cur);
            while(cur.left!=null){
                cur=cur.left;
                stack.push(cur);
            }
            cur=null;
            while(!stack.isEmpty()){
                pre=cur;
                cur=stack.pop();
                if(pre==p){
                    return cur;
                }
                if(cur.right!=null){
                    stack.push(cur.right);
                }
            }
            return null;
        }
        return null;
    }
```



![image-20220516122626262](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516122626262.png)

这里有点问题啊,两个while循环被割裂开了，我要做的是把每一棵树的左节点都放入栈，我这里只把最大的树的左节点放入了栈，所以一定出问题



第二次提交

很聪明的让cur.left的加入和cur.right的加入在一个while循环中进行

很聪明的加入了count元素，让pre在第一次等于Null，后面均等于cur，然鹅还是出错，我服了。

```java
import java.util.Stack;

class Solution {
    public static TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur=root;
        TreeNode pre=null;
        int count=0;
        if(root!=null){
            Stack<TreeNode> stack=new Stack<>();
            stack.push(cur);
            while(!stack.isEmpty()) {
                if (cur.left != null) {
                    cur = cur.left;
                    stack.push(cur);
                } else {
                    if(count==0){
                        pre=null;
                        count++;
                    }else {
                        pre=cur;
                    }
                        cur = stack.pop();
                        if (pre == p) {
                            return cur;
                        }
                        if (cur.right != null) {
                            stack.push(cur.right);
                        }

                }

            }
            return null;
        }
        return null;
    }
}
```

![image-20220516130046045](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516130046045.png)



正确答案

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode prev = null, curr = root;
        while (!stack.isEmpty() || curr != null) {
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            if (prev == p) {
                return curr;
            }
            prev = curr;
            curr = curr.right;
        }
        return null;
    }
}
```

当然，由于题目上给了是一个BST，所以可以直接使用BST的性质

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        //递归终止条件
        if (root == null) return null;
        //root值小于等于p直接去右边root找
        if (root.val <= p.val) return inorderSuccessor(root.right, p);
        TreeNode ans = inorderSuccessor(root.left, p);
        return ans == null ? root : ans;
    }
}
```

5.17

状态dp问题:

打家劫舍1

![image-20220518001321249](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001321249.png)

打家劫舍2

![image-20220518001350161](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001350161.png)

打家劫舍3(树形dp)

![image-20220518001433874](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001433874.png)



贪心算法:

跳跃游戏

![image-20220518001512559](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001512559.png)

零钱兑换

![image-20220518001541649](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001541649.png)



前缀和问题:

相同元素的间隔之和

![image-20220518001613498](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001613498.png)

5.18

![image-20220519221123673](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220519221123673.png)

简单做法:

使用贪心策略知这个数中位数时最小

```java
public int minMoves2(int[] nums) {
    Arrays.sort(nums);
    int n=nums.length;
    int mid=(n-1)/2;
    int ans=0;
    for (int i = 0; i < n; i++) {
        ans+=Math.abs(nums[i]-nums[mid]);
    }
    return ans;
}
```

优化:

快速选择使事件复杂度进一步减小,用于解决topk问题





215 数组中第k大的元素
![image-20220519221404241](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220519221404241.png)

法一:维护一个堆

因为要求第k大的元素，我们可以维护一个容量大小为k的堆,堆顶元素就是第k大的元素

法二:快速选择

对于动态数据流只能使用堆排序

核心思想是随机选择一个轴值，对于小于该轴值的数放在轴值左边，大于该轴值的数放在轴值右边,然后根据k和轴值的关系

平均时间复杂度on 

5.20 每日一题

自己做:暴力

```java
class Solution {
        public int[] findRightInterval(int[][] intervals) {
        int n = intervals.length;
        int[] ans = new int[n];
        int temp = -1;
        int minInterval = Integer.MAX_VALUE;
        if (n == 1) {
            ans[0] = -1;
            return ans;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (intervals[j][0] - intervals[i][1] < minInterval) {
                    minInterval = intervals[j][0];
                    temp = j;
                }
            }
            ans[i] = temp;
            minInterval=Integer.MAX_VALUE;
        }
        return ans;
    }
}
```

5.21

每日一题(简单)



98.验证二叉搜索树

中序遍历

1.递归实现

出问题了

```java
    public boolean isValidBST(TreeNode root) {
    if(root==null){
        return true;
    }
    if(root.left!=null){
        isValidBST(root.left);
    }
    if(this.val>this.left.val&&this.val<this.right.val){
        return true;
    }
    if(root.right!=null){
        isValidBST(root.right);
    }
    }
```

2.栈实现

气死我了卡数值范围

把pre改成Long.MIN_VALUE即可

```java
class Solution {
       public boolean isValidBST(TreeNode root) {
        if(root!=null) {
            Stack<TreeNode> stack = new Stack<>();
            long pre=Long.MIN_VALUE;
            while(!stack.isEmpty() || root!=null){
                if(root!=null){
                    stack.add(root);
                    root=root.left;
                }else {
                    root=stack.pop();
                    if(root.val<=pre){
                        return false;
                    }else {
                        pre=root.val;
                    }
                    root=root.right;
                }
            }
        }
        return true;
    }
}

```



3.递归套路



292场周赛第二题

统计值等于子树平均值的节点数

![image-20220521172719000](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220521172719000.png)

思路:从子树想父亲拓展，由子树的平均值算出父树的平均值，使用递归处理，比较难以解决的是子树的平均值如何转化到父亲的平均值:

使用一个leftcnt记录左子树的节点数一个rightcnt右子树的结点数目，

由于cnt是每个树自身特有的，所以定义在dfs中

总结:还是代码能力不够，不能很好地在递归过程中动态处理数据.

理解递归过程

写一段代码

```java
class Solution {
    int cnt=1;
    int answer=0;

    public int dfs(TreeNode head){
        int ans=head.val;
        if(head.left!=null){
            ans+=dfs(head.left)*cnt;
        }
        if(head.right!=null){
            ans+=dfs(head.right)*cnt;
        }
        if(ans/cnt==head.val){
            answer+=1;
        }
        System.out.println(head.val+":" +ans+":"+cnt);
        cnt+=1;
        return ans/cnt;
    }
    public int averageOfSubtree(TreeNode root) {
        int x = dfs(root);
        return answer;

    }

    public static void main(String[] args) {
        TreeNode treeNode1 = new TreeNode(4);
        TreeNode treeNode2 = new TreeNode(8);
        TreeNode treeNode3 = new TreeNode(0);
        TreeNode treeNode4 = new TreeNode(1);
        TreeNode treeNode5 = new TreeNode(5);
        TreeNode treeNode6 = new TreeNode(6);
        treeNode1.left=treeNode2;
        treeNode2.left=treeNode3;
        treeNode2.right=treeNode4;
        treeNode1.right=treeNode5;
        treeNode5.right=treeNode6;
        Solution solution = new Solution();
        solution.averageOfSubtree(treeNode1);

    }
}
  class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
 }
```

贪心问题:

剑指offer103最少的硬币数

![image-20220521222536218](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220521222536218.png)

我开始做的贪心是能取最大面额就取最大面额，否则取较小的那一个，但是有一个漏洞，就是当硬币面额不是倍数关系时有时候明明能兑换但我误判了不能换.

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int ans=0;
        Arrays.sort(coins);
        int i=coins.length-1;
        while(i>=0){
            if(coins[i]<=amount&&amount>=0){
                ans++;
                amount-=coins[i];
            }else{
                i--;
            }
        }
        if(amount>0){
            return -1;
        }
        return ans;
    }
}
```

错误案例

5.22

周赛

1.简单

![image-20220522182844393](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182844393.png)

```java
class Solution {
        public int percentageLetter(String s, char letter) {
        int sum=0;
        char[] chars = s.toCharArray();
        for(char chr:chars){
            if(chr==letter){
                sum+=100;
            }
        }
        return  sum/s.length();
    }
}

```

2.![image-20220522182809356](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182809356.png)

思路:堆

```java
class Solution {
        public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int sum=0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i = 0; i < capacity.length; i++) {
            pq.add(capacity[i]-rocks[i]);
        }
        while(!pq.isEmpty()&&pq.peek()<=additionalRocks&&additionalRocks>=0){
            additionalRocks-=pq.poll();
            sum++;
        }
        return sum;
    }
}
```

3.

![image-20220522120723328](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220522120723328.png)

![image-20220522182545216](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182545216.png)

思路:排序+双指针

注意不能用斜率，斜率全部转化为相等.

```java
class Solution {
        public int minimumLines(int[][] stockPrices) {
        if(stockPrices.length==1){
            return 0;
        }
        int ans=0;
        Arrays.sort(stockPrices,new mycomparator());
        int l=0;
        int r=1;
        while(r<stockPrices.length){
            int curx1=stockPrices[l+1][0]-stockPrices[l][0];
            int cury1=stockPrices[l+1][1]-stockPrices[l][1];
            int curx2=stockPrices[r][0]-stockPrices[l][0];
            int cury2=stockPrices[r][1]-stockPrices[l][1];
            if(curx1*cury2==curx2*cury1){
                r++;
            }else{
                ans++;
                l=r-1;
                r=l+1;
            }
        }
        ans++;
        return ans;
    }
}
class mycomparator implements Comparator<int[]> {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0] - o2[0];
    }
}
```

大佬

```java
class Solution {

	public int minimumLines(int[][] stockPrices) {
		Arrays.sort(stockPrices, (o, p) -> o[0] - p[0]);
		int count = 0;
		for (int i = 1; i < stockPrices.length; i++) {
			count += i > 1 && (long) (stockPrices[i][0] - stockPrices[i - 1][0]) * (stockPrices[i - 1][1]
					- stockPrices[i - 2][1]) == (long) (stockPrices[i - 1][0] - stockPrices[i - 2][0])
							* (stockPrices[i][1] - stockPrices[i - 1][1]) ? 0 : 1;
		}
		return count;
	}
}
```



4.

![image-20220522182725855](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182725855.png)
