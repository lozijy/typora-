链表

题目:

1.判断一个链表是否有环？

方法一:哈希表(开辟额外空间)

方法二:快慢指针(原地算法)

2.2个链表可能有环可能无环，判断两个链表是非相交，若相交则返回相交结点，否则返回null

二叉树

题目:

1.递归实现前序遍历，中序遍历，后序遍历

先理解一个递归序

```java
public static void f(TreeNode node){
    if(node ==null){
        return;
    }
    f(node.leftChild);
    f(node.rightChild);
}
```

对于这样一个函数执行顺序是怎样的?

![image-20220516101612514](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516101612514.png)

执行顺序:124888442555213666379997731,重点理解这个过程,这里我们什么都没做，这个过程是不可见的，但它确实发生了。在需要做事的时候添加相应操作即可

```java

//前序遍历
public static void preOrderTraveral(TreeNode node) {
    if(node==null){
        return;
    }
    System.out.println(node.value);
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
}
//中序遍历
public static void inOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    System.out.println(node.value);
    preOrderTraveral(node.rightChild);
}
public static void postOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
    System.out.println(node.value);
}
```



2.非递归实现前序遍历，中序遍历，后序遍历

面试常考,任何递归都可以转化为非递归循环，系统无法帮我们压栈我们就自己压栈。

前序遍历：中，左，右我们压栈反着来，先压中，弹出，在压右，再压左，再弹出。

```java
    //前序遍历
    public static void preOrderTraveral2(TreeNode node){
        if (node !=null){
            Stack<TreeNode> stack = new Stack<>();
            stack.push(node);
            while(!stack.isEmpty()){
                node=stack.pop();
                System.out.println(node.value+" ");
                if(node.rightChild !=null){
                    stack.push(node.rightChild);
                }
                if(node.leftChild !=null){
                    stack.push(node.leftChild);
                }
            }
        }
    }
```

中序遍历:把所有左节点放入栈，然后依次pop，pop后若有右节点则把右节点push

```java
//中序遍历
public static void inOrderTraveral2(TreeNode head){
    if(head!=null){
        Stack<TreeNode> stack = new Stack<>();
        stack.push(head);
        while(head.leftChild!=null){
            head=head.leftChild;
            stack.push(head);
        }
        while(!stack.isEmpty()){
            head=stack.pop();
            System.out.println(head.value+" ");
            while(head.rightChild!=null){
                head=head.rightChild;
                stack.push(head);
            }
        }
    }
}
```

老师给的

```java
public static void inOrderTraveral3(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty()||head !=null){
            if(head!=null){
                stack.push(head);
                head=head.leftChild;
            }else {
                head=stack.pop();
                System.out.println(head.value+" ");
                head=head.rightChild;
            }
        }
    }
}
```

后序遍历：

```java
//后序遍历
public static void postOrderTraveral2(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(head);
        while(!stack1.isEmpty()){
            head= stack1.pop();
            stack2.push(head);
            if(head.leftChild!=null){
                stack1.push(head.leftChild);
            }
            if(head.rightChild!=null){
                stack1.push(head.rightChild);
            }
        }
        while(!stack2.isEmpty()){
            System.out.println(stack2.pop().value+" ");
        }
    }
    System.out.println();
}
```

3.非递归实现层序遍历

4.面试题:打印出一棵树的最大宽度

