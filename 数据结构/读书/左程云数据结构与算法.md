### 链表

题目:

1.判断一个链表是否有环？

方法一:哈希表(开辟额外空间)

方法二:快慢指针(原地算法)

2.2个链表可能有环可能无环，判断两个链表是非相交，若相交则返回相交结点，否则返回null

### 二叉树

题目:

1.递归实现前序遍历，中序遍历，后序遍历

先理解一个递归序

```java
public static void f(TreeNode node){
    if(node ==null){
        return;
    }
    f(node.leftChild);
    f(node.rightChild);
}
```

对于这样一个函数执行顺序是怎样的?

![image-20220516101612514](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516101612514.png)

执行顺序:124888442555213666379997731,重点理解这个过程,这里我们什么都没做，这个过程是不可见的，但它确实发生了。在需要做事的时候添加相应操作即可

```java

//前序遍历
public static void preOrderTraveral(TreeNode node) {
    if(node==null){
        return;
    }
    System.out.println(node.value);
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
}
//中序遍历
public static void inOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    System.out.println(node.value);
    preOrderTraveral(node.rightChild);
}
public static void postOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
    System.out.println(node.value);
}
```



2.非递归实现前序遍历，中序遍历，后序遍历

面试常考,任何递归都可以转化为非递归循环，系统无法帮我们压栈我们就自己压栈。

前序遍历：中，左，右我们压栈反着来，先压中，弹出，在压右，再压左，再弹出。

```java
    //前序遍历
    public static void preOrderTraveral2(TreeNode node){
        if (node !=null){
            Stack<TreeNode> stack = new Stack<>();
            stack.push(node);
            while(!stack.isEmpty()){
                node=stack.pop();
                System.out.println(node.value+" ");
                if(node.rightChild !=null){
                    stack.push(node.rightChild);
                }
                if(node.leftChild !=null){
                    stack.push(node.leftChild);
                }
            }
        }
    }
```

中序遍历:

把所有左节点放入栈，然后依次pop，pop后若有右节点则把右节点push

```java
//中序遍历
public static void inOrderTraveral2(TreeNode head){
    if(head!=null){
        Stack<TreeNode> stack = new Stack<>();
        stack.push(head);
        while(head.leftChild!=null){
            head=head.leftChild;
            stack.push(head);
        }
        while(!stack.isEmpty()){
            head=stack.pop();
            System.out.println(head.value+" ");
            while(head.rightChild!=null){
                head=head.rightChild;
                stack.push(head);
            }
        }
    }
}
```

老师给的

```java
public static void inOrderTraveral3(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty()||head !=null){
            if(head!=null){
                stack.push(head);
                head=head.leftChild;
            }else {
                head=stack.pop();
                System.out.println(head.value+" ");
                head=head.rightChild;
            }
        }
    }
}
```

后序遍历：

创建2个栈，第一个栈存放顺序:中，左，右，那么第二个栈存放顺序为中，右，左，取出顺序为左，右，中

```java
//后序遍历
public static void postOrderTraveral2(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(head);
        while(!stack1.isEmpty()){
            head= stack1.pop();
            stack2.push(head);
            if(head.leftChild!=null){
                stack1.push(head.leftChild);
            }
            if(head.rightChild!=null){
                stack1.push(head.rightChild);
            }
        }
        while(!stack2.isEmpty()){
            System.out.println(stack2.pop().value+" ");
        }
    }
    System.out.println();
}
```

3.非递归实现层序遍历

使用队列,linklist可以直接作为队列add入队，poll出队，

依次把中，左，右入队即可.

```java
//层序遍历
public static void levelOrderTraveral(TreeNode head){
    if(head!=null){
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(head);
        while(!queue.isEmpty()){
            head=queue.poll();
            System.out.println(head.value+" ");
            if(head.leftChild!=null){
                queue.add(head.leftChild);
            }
            if(head.rightChild!=null){
                queue.add(head.rightChild);
            }
        }
    }
}
```

4.面试题:打印出一棵树的最大宽度

关键是记录哪些节点是同一层级，使用hashmap记录

也可以不使用hashmap

5.判断一颗二叉树是否是一颗二叉搜索树

可以使用栈，也可以使用递归，也可以使用树形dp套路

递归动态判断

```java
    //判断是否是二叉搜索树，使用递归动态判断
    public static int preValue=Integer.MIN_VALUE;
    public static boolean checkBST(TreeNode head){
        if(head==null){
            return true;
        }
        boolean isLeftBst=checkBST(head.leftChild);
        if(!isLeftBst){
            return false;
        }
        if(head.value<=preValue){
            return false;
        }else {
            preValue=head.value;
        }
        return checkBST(head.rightChild);
    }
```

递归+数组储存每一个结点

```java
//判断是否为二叉搜索树,使用递归+数组储存实现
public static  boolean checkBST2(TreeNode head){
    boolean flag=true;
    List<TreeNode> list = new LinkedList<>();
    process(head,list);
    //遍历判断数组，判断是否是升序的.
    for (int i = 0; i < list.size(); i++) {
        if(list.get(i).value>=list.get(i+1).value){
            flag=false;
        }
    }
    return flag;
}
//递归将中序遍历数据存在数组中
public static void process(TreeNode head,List<TreeNode> inOrderList){
    if(head ==null){
        return;
    }
    process(head.leftChild,inOrderList);
    inOrderList.add(head);
    process(head.rightChild,inOrderList);
}
```

非递归的方式

```java
//使用非递归的方式将
public static boolean checkBST3(TreeNode head) {
    if (head != null) {
        int pre=Integer.MIN_VALUE;
        Stack<TreeNode> stack = new Stack<>();
        while (head != null || !stack.isEmpty()) {
            if (head != null) {
                stack.push(head);
                head = head.leftChild;
            } else {
                head = stack.pop();
                //中间是中序遍历的时候，更改代码实现逻辑
                if(head.value<=preValue){
                    return false;
                }else {
                    preValue=head.value;
                }
                head = head.rightChild;
            }
        }
    }
    return true;
}
```

6.判断一颗二叉树是否是一颗完全二叉树

使用层序遍历，满足2个条件1.若出现有右孩子无左孩子的情况直接返回false.2.在1的条件下若出现只有一个孩子，但它后面出现非叶子结点的情况下返回false.

```java
//判断是否是完全二叉树
public static boolean checkCBT(TreeNode head){
    if(head!=null){
        boolean flag=false;
        Queue<TreeNode> queue =new LinkedList<TreeNode>();
        queue.add(head);
        while(!queue.isEmpty()){
            head=queue.poll();
            if(head.leftChild==null&& head.rightChild!=null) {
                return false;
            }
            if(head.rightChild==null){
                flag=true;
            }
            if(flag && (head.leftChild!=null || head.rightChild!=null)){
                return false;
            }
            if(head.leftChild!=null){
                head=head.leftChild;
            }
            if(head.rightChild!=null){
                head=head.rightChild;
            }
        }
        return false;//循环结束仍然接受住考验则返回true
    }
    return true;//root为null直接返回true
}
```

7.判断一颗二叉树是否是满二叉树

树形dp套路

```java
//判断是否为满二叉树

public static boolean checkFBT(TreeNode head){
    if(head==null){
        return true;
    }
    Info info = process(head);
    if(info.nodes ==1<<info.height-1){
        return true;
    }
    return false;
};
public static Info process(TreeNode head){
    //别忘记这一行代码,是递归结束的必要条件
    if(head==null){
        return new Info(0,0);
    }
    Info leftInfo=process(head.leftChild);
    Info rightInfo=process(head.rightChild);
    int h=Math.max(leftInfo.height,rightInfo.height)+1;
    int nodes=leftInfo.nodes+rightInfo.nodes+1;
    return new Info(h,nodes);
}
class Info{
    int height;
    int nodes;
    public Info(int h,int nodes){
        this.height=h;
        this.nodes=nodes;
    }
```

8.判断一颗二叉树是否是平衡二叉树



