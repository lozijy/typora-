### 链表

题目:

1.判断一个链表是否有环？

方法一:哈希表(开辟额外空间)

方法二:快慢指针(原地算法)

2.2个链表可能有环可能无环，判断两个链表是非相交，若相交则返回相交结点，否则返回null

### 二叉树

题目:

1.递归实现前序遍历，中序遍历，后序遍历

先理解一个递归序

```java
public static void f(TreeNode node){
    if(node ==null){
        return;
    }
    f(node.leftChild);
    f(node.rightChild);
}
```

对于这样一个函数执行顺序是怎样的?

![image-20220516101612514](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516101612514.png)

执行顺序:124888442555213666379997731,重点理解这个过程,这里我们什么都没做，这个过程是不可见的，但它确实发生了。在需要做事的时候添加相应操作即可

```java

//前序遍历
public static void preOrderTraveral(TreeNode node) {
    if(node==null){
        return;
    }
    System.out.println(node.value);
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
}
//中序遍历
public static void inOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    System.out.println(node.value);
    preOrderTraveral(node.rightChild);
}
public static void postOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
    System.out.println(node.value);
}
```



2.非递归实现前序遍历，中序遍历，后序遍历

面试常考,任何递归都可以转化为非递归循环，系统无法帮我们压栈我们就自己压栈。

前序遍历：中，左，右我们压栈反着来，先压中，弹出，在压右，再压左，再弹出。

```java
    //前序遍历
    public static void preOrderTraveral2(TreeNode node){
        if (node !=null){
            Stack<TreeNode> stack = new Stack<>();
            stack.push(node);
            while(!stack.isEmpty()){
                node=stack.pop();
                System.out.println(node.value+" ");
                if(node.rightChild !=null){
                    stack.push(node.rightChild);
                }
                if(node.leftChild !=null){
                    stack.push(node.leftChild);
                }
            }
        }
    }
```

中序遍历:

把所有左节点放入栈，然后依次pop，pop后若有右节点则把右节点push

```java
//中序遍历
public static void inOrderTraveral2(TreeNode head){
    if(head!=null){
        Stack<TreeNode> stack = new Stack<>();
        stack.push(head);
        while(head.leftChild!=null){
            head=head.leftChild;
            stack.push(head);
        }
        while(!stack.isEmpty()){
            head=stack.pop();
            System.out.println(head.value+" ");
            while(head.rightChild!=null){
                head=head.rightChild;
                stack.push(head);
            }
        }
    }
}
```

老师给的

```java
public static void inOrderTraveral3(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty()||head !=null){
            if(head!=null){
                stack.push(head);
                head=head.leftChild;
            }else {
                head=stack.pop();
                System.out.println(head.value+" ");
                head=head.rightChild;
            }
        }
    }
}
```

后序遍历：

创建2个栈，第一个栈存放顺序:中，左，右，那么第二个栈存放顺序为中，右，左，取出顺序为左，右，中

```java
//后序遍历
public static void postOrderTraveral2(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(head);
        while(!stack1.isEmpty()){
            head= stack1.pop();
            stack2.push(head);
            if(head.leftChild!=null){
                stack1.push(head.leftChild);
            }
            if(head.rightChild!=null){
                stack1.push(head.rightChild);
            }
        }
        while(!stack2.isEmpty()){
            System.out.println(stack2.pop().value+" ");
        }
    }
    System.out.println();
}
```

3.非递归实现层序遍历

使用队列,linklist可以直接作为队列add入队，poll出队，

依次把中，左，右入队即可.

```java
//层序遍历
public static void levelOrderTraveral(TreeNode head){
    if(head!=null){
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(head);
        while(!queue.isEmpty()){
            head=queue.poll();
            System.out.println(head.value+" ");
            if(head.leftChild!=null){
                queue.add(head.leftChild);
            }
            if(head.rightChild!=null){
                queue.add(head.rightChild);
            }
        }
    }
}
```

4.面试题:打印出一棵树的最大宽度

关键是记录哪些节点是同一层级，使用hashmap记录

也可以不使用hashmap

5.判断一颗二叉树是否是一颗二叉搜索树

可以使用栈，也可以使用递归，也可以使用树形dp套路

递归动态判断

```java
    //判断是否是二叉搜索树，使用递归动态判断
    public static int preValue=Integer.MIN_VALUE;
    public static boolean checkBST(TreeNode head){
        if(head==null){
            return true;
        }
        boolean isLeftBst=checkBST(head.leftChild);
        if(!isLeftBst){
            return false;
        }
        if(head.value<=preValue){
            return false;
        }else {
            preValue=head.value;
        }
        return checkBST(head.rightChild);
    }
```

递归+数组储存每一个结点

```java
//判断是否为二叉搜索树,使用递归+数组储存实现
public static  boolean checkBST2(TreeNode head){
    boolean flag=true;
    List<TreeNode> list = new LinkedList<>();
    process(head,list);
    //遍历判断数组，判断是否是升序的.
    for (int i = 0; i < list.size(); i++) {
        if(list.get(i).value>=list.get(i+1).value){
            flag=false;
        }
    }
    return flag;
}
//递归将中序遍历数据存在数组中
public static void process(TreeNode head,List<TreeNode> inOrderList){
    if(head ==null){
        return;
    }
    process(head.leftChild,inOrderList);
    inOrderList.add(head);
    process(head.rightChild,inOrderList);
}
```

非递归的方式

```java
//使用非递归的方式将
public static boolean checkBST3(TreeNode head) {
    if (head != null) {
        int pre=Integer.MIN_VALUE;
        Stack<TreeNode> stack = new Stack<>();
        while (head != null || !stack.isEmpty()) {
            if (head != null) {
                stack.push(head);
                head = head.leftChild;
            } else {
                head = stack.pop();
                //中间是中序遍历的时候，更改代码实现逻辑
                if(head.value<=preValue){
                    return false;
                }else {
                    preValue=head.value;
                }
                head = head.rightChild;
            }
        }
    }
    return true;
}
```

6.判断一颗二叉树是否是一颗完全二叉树

使用层序遍历，满足2个条件1.若出现有右孩子无左孩子的情况直接返回false.2.在1的条件下若出现只有一个孩子，但它后面出现非叶子结点的情况下返回false.

```java
//判断是否是完全二叉树
public static boolean checkCBT(TreeNode head){
    if(head!=null){
        boolean flag=false;
        Queue<TreeNode> queue =new LinkedList<TreeNode>();
        queue.add(head);
        while(!queue.isEmpty()){
            head=queue.poll();
            if(head.leftChild==null&& head.rightChild!=null) {
                return false;
            }
            if(head.rightChild==null){
                flag=true;
            }
            if(flag && (head.leftChild!=null || head.rightChild!=null)){
                return false;
            }
            if(head.leftChild!=null){
                head=head.leftChild;
            }
            if(head.rightChild!=null){
                head=head.rightChild;
            }
        }
        return false;//循环结束仍然接受住考验则返回true
    }
    return true;//root为null直接返回true
}
```

7.判断一颗二叉树是否是满二叉树

树形dp套路

```java
//判断是否为满二叉树

public static boolean checkFBT(TreeNode head){
    if(head==null){
        return true;
    }
    Info info = process(head);
    if(info.nodes ==1<<info.height-1){
        return true;
    }
    return false;
};
public static Info process(TreeNode head){
    //别忘记这一行代码,是递归结束的必要条件
    if(head==null){
        return new Info(0,0);
    }
    Info leftInfo=process(head.leftChild);
    Info rightInfo=process(head.rightChild);
    int h=Math.max(leftInfo.height,rightInfo.height)+1;
    int nodes=leftInfo.nodes+rightInfo.nodes+1;
    return new Info(h,nodes);
}
class Info{
    int height;
    int nodes;
    public Info(int h,int nodes){
        this.height=h;
        this.nodes=nodes;
    }
```

8.判断一颗二叉树是否是平衡二叉树

9.寻找两个结点的最低公共祖先结点

```java
//寻找两个结点的最低公共祖先结点,使用哈希表
public static TreeNode lowestCommonAncestor(TreeNode head,TreeNode o1,TreeNode o2){
    HashMap<TreeNode, TreeNode> fatherMap = new HashMap<>();
    process3(head,fatherMap);
    HashSet<TreeNode> set = new HashSet<>();
    TreeNode cur=o1;
    //在cur不为头结点的情况下让o1向上穿,循环结束后除了头结点head均放入了set
    while(cur!=fatherMap.get(cur)){
        set.add(cur);
        cur=fatherMap.get(cur);
    }
    set.add(head);
    cur=o2;
    //cur指向o2，不断变成自己的父节点,每一次变都会判断其是否在set中存在,若循环结束仍然不存在,说明头结点是最低公共祖先
    while(cur!=fatherMap.get(cur)){
        if(set.contains(cur)){
            return cur;
        }
        cur=fatherMap.get(cur);
    }
    return head;
}
public static void process3(TreeNode head,HashMap<TreeNode,TreeNode> fatherMap){
    if(head==null){//basecase
        return;
    }
    fatherMap.put(head.leftChild,head);
    fatherMap.put(head.rightChild,head);
    process3(head.leftChild,fatherMap);
    process3(head.rightChild,fatherMap);
}
```



```java
//寻找两个结点的最低公共祖先,使用递归动态判断
public static TreeNode lowestCommonAncestor2(TreeNode head,TreeNode o1,TreeNode o2){
    //base case
    if(head==null||head==o1||head==o2){
        return head;
    }
    //在左树上寻找
    TreeNode left=lowestCommonAncestor2(head.leftChild,o1,o2);
    TreeNode right=lowestCommonAncestor2(head.rightChild,o1,o2);
    if(left==null&&right==null){
        return head;
    }
    //左右有一个不为空的情况返回不为空的那一个()
    return left!=null?left:right;
    
}
```

寻找一个结点的后继结点,假设结点中有parent属性

![image-20220517182400062](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220517182400062.png)



二叉树的序列化，反序列化

序列化

```java
//递归实现二叉树的序列化
public static String serialByPre(TreeNode head){
    if(head==null){
        return "#_";
    }
    String res=head.value+"_";
    res+=serialByPre(head.leftChild);
    res+=serialByPre(head.rightChild);
    return res;
}
```

![image-20220517182544183](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220517182544183.png)



反序列化

```java
//层序遍历实现二叉树的反序列化
public static TreeNode reconByPreString(String preStr){
    String[]values=preStr.split(",");
    Queue<String> queue = new LinkedList<>();
    for (int i = 0; i < values.length; i++) {
        queue.add(values[i]);
    }
    return reconPreOrder(queue);
}
public static TreeNode reconPreOrder(Queue<String> queue){
    String value=queue.poll();
    if(value.equals("#")){
        return null;
    }
    TreeNode head=new TreeNode(Integer.parseInt(value));
    head.leftChild=reconPreOrder(queue);
    head.rightChild=reconPreOrder(queue);
    return head;
}
```

微软原题

打印折痕

```java
//微软原题,折纸问题，抽象为一颗二叉树
public static void printProcess(int n){
    process(0,n,true);
}
public static void process(int i,int n,boolean down){
    if(i>n){
        return;
    }
    process(i+1,n,true);
    System.out.println(down?"凹":"凸");
    process(i+1,n,false);
}
```

### 图

图的基本结构

```java
import java.util.HashMap;
import java.util.HashSet;

public class Graph {
    HashMap<Integer,Node>Nodes;
    HashSet<edge>edges;

    public Graph() {
    }
}
```

点的基本结构

```java
import java.util.ArrayList;

public class Node {
    public int value;//值
    public int in;//入度
    public int out;//出度
    public ArrayList<Node>nexts;//下一个点
    public ArrayList<edge>edges;//边

    public Node(int value, int in, int out) {
        this.value = value;
        this.in = in;
        this.out = out;
    }
}
```

边的基本结构

```java
public class edge {
    int weight;//权重
    Node from;//从某个点来
    Node to;//到某个点去

    public edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

将其他形式的图转化为我们熟悉的图



图的广度优先遍历(bfs)

```java
//宽度优先遍历(队列实现,set维护)
public static void bfs(Node node){
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();
    queue.add(node);
    set.add(node);
    while(!queue.isEmpty()){
        //开始统一处理
        Node cur=queue.poll();
        //处理cur
        System.out.println(cur.value);
        //将所有宽度放入队列最后统一处理
        for(Node next:cur.nexts){
            if(!set.contains(next)){
                queue.add(next);
                set.add(next);
            }
        }
    }
}
```



图的深度优先遍历 (dfs)

```java
public static void dfs(Node node){
    if (node==null){
        return;
    }
    Stack<Node> stack = new Stack<>();
    HashSet<Node> set = new HashSet<>();//新建一个hashset动态维护保证每一个结点仅出现一次
    Node cur=node;
    stack.push(cur);
    set.add(cur);
    System.out.println(cur);
    while(!stack.isEmpty()){
        cur=stack.pop();
        for (Node next:cur.nexts) {
            if (!set.contains(next)) {
                stack.push(cur);
                stack.push(next);
                set.add(next) ;
                //处理这个邻居
                System.out.println(next.value);
                //把邻居加进去后就不看A后面的结点了
                break;
            }
        }
    }
}
```

图的拓扑排序

概念:

在图论中，**拓扑排序（Topological Sorting**）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

1. 每个顶点出现且只出现一次。
2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。

方法:

如果图中一个结点的入度为零，则将其本身以及对后继节点的影响擦去，并将其放入数组之中.

实现

```java
//拓扑排序
public static List<Node> sortedTopology(Graph graph) {
    HashMap<Node, Integer> inMap = new HashMap<>();//储存每一个节点的入度
    Queue<Node> zeroQueue = new LinkedList<>();//储存每一个入度为零的结点
    //将每一个结点的入度存入hashmap
    for(Node node:graph.Nodes.values()){
            inMap.put(node,node.in);
            if(node.in==0){
                zeroQueue.add(node);
            }
    }
    //将拓扑排序的结果加入到结果集中
    LinkedList<Node> result = new LinkedList<>();
    while(!zeroQueue.isEmpty()){
        Node cur=zeroQueue.poll();
        result.add(cur);
        //擦除其对后继节点的影响
        for(Node next:cur.nexts) {
            inMap.put(next, cur.in - 1);
            if(next.in==0){
                zeroQueue.add(next);
            }
        }
    }
    return result;
}
```
