### 时间复杂度的计算

递归行为的时间复杂度的估算

master公式的使用

### 认识时间复杂度为nlogn的排序算法

归并排序

快排

快速选择(快速解决topk问题)





### 详解桶排序





### 链表

题目:

1.判断一个链表是否有环？

方法一:哈希表(开辟额外空间)

方法二:快慢指针(原地算法)

2.2个链表可能有环可能无环，判断两个链表是非相交，若相交则返回相交结点，否则返回null

### 二叉树

题目:

1.递归实现前序遍历，中序遍历，后序遍历

先理解一个递归序

```java
public static void f(TreeNode node){
    if(node ==null){
        return;
    }
    f(node.leftChild);
    f(node.rightChild);
}
```

对于这样一个函数执行顺序是怎样的?

![image-20220516101612514](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516101612514.png)

执行顺序:124888442555213666379997731,重点理解这个过程,这里我们什么都没做，这个过程是不可见的，但它确实发生了。在需要做事的时候添加相应操作即可

```java

//前序遍历
public static void preOrderTraveral(TreeNode node) {
    if(node==null){
        return;
    }
    System.out.println(node.value);
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
}
//中序遍历
public static void inOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    System.out.println(node.value);
    preOrderTraveral(node.rightChild);
}
public static void postOrderTraveral(TreeNode node){
    if(node==null){
        return;
    }
    preOrderTraveral(node.leftChild);
    preOrderTraveral(node.rightChild);
    System.out.println(node.value);
}
```



2.非递归实现前序遍历，中序遍历，后序遍历

面试常考,任何递归都可以转化为非递归循环，系统无法帮我们压栈我们就自己压栈。

前序遍历：中，左，右我们压栈反着来，先压中，弹出，在压右，再压左，再弹出。

```java
    //前序遍历
    public static void preOrderTraveral2(TreeNode node){
        if (node !=null){
            Stack<TreeNode> stack = new Stack<>();
            stack.push(node);
            while(!stack.isEmpty()){
                node=stack.pop();
                System.out.println(node.value+" ");
                if(node.rightChild !=null){
                    stack.push(node.rightChild);
                }
                if(node.leftChild !=null){
                    stack.push(node.leftChild);
                }
            }
        }
    }
```

中序遍历:

把所有左节点放入栈，然后依次pop，pop后若有右节点则把右节点push

```java
//中序遍历
public static void inOrderTraveral2(TreeNode head){
    if(head!=null){
        Stack<TreeNode> stack = new Stack<>();
        stack.push(head);
        while(head.leftChild!=null){
            head=head.leftChild;
            stack.push(head);
        }
        while(!stack.isEmpty()){
            head=stack.pop();
            System.out.println(head.value+" ");
            while(head.rightChild!=null){
                head=head.rightChild;
                stack.push(head);
            }
        }
    }
}
```

老师给的

```java
public static void inOrderTraveral3(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty()||head !=null){
            if(head!=null){
                stack.push(head);
                head=head.leftChild;
            }else {
                head=stack.pop();
                System.out.println(head.value+" ");
                head=head.rightChild;
            }
        }
    }
}
```

后序遍历：

创建2个栈，第一个栈存放顺序:中，左，右，那么第二个栈存放顺序为中，右，左，取出顺序为左，右，中

```java
//后序遍历
public static void postOrderTraveral2(TreeNode head){
    if(head !=null){
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(head);
        while(!stack1.isEmpty()){
            head= stack1.pop();
            stack2.push(head);
            if(head.leftChild!=null){
                stack1.push(head.leftChild);
            }
            if(head.rightChild!=null){
                stack1.push(head.rightChild);
            }
        }
        while(!stack2.isEmpty()){
            System.out.println(stack2.pop().value+" ");
        }
    }
    System.out.println();
}
```

3.非递归实现层序遍历

使用队列,linklist可以直接作为队列add入队，poll出队，

依次把中，左，右入队即可.

```java
//层序遍历
public static void levelOrderTraveral(TreeNode head){
    if(head!=null){
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(head);
        while(!queue.isEmpty()){
            head=queue.poll();
            System.out.println(head.value+" ");
            if(head.leftChild!=null){
                queue.add(head.leftChild);
            }
            if(head.rightChild!=null){
                queue.add(head.rightChild);
            }
        }
    }
}
```

4.面试题:打印出一棵树的最大宽度

关键是记录哪些节点是同一层级，使用hashmap记录

也可以不使用hashmap

5.判断一颗二叉树是否是一颗二叉搜索树

可以使用栈，也可以使用递归，也可以使用树形dp套路

递归动态判断

```java
    //判断是否是二叉搜索树，使用递归动态判断
    public static int preValue=Integer.MIN_VALUE;
    public static boolean checkBST(TreeNode head){
        if(head==null){
            return true;
        }
        boolean isLeftBst=checkBST(head.leftChild);
        if(!isLeftBst){
            return false;
        }
        if(head.value<=preValue){
            return false;
        }else {
            preValue=head.value;
        }
        return checkBST(head.rightChild);
    }
```

递归+数组储存每一个结点

```java
//判断是否为二叉搜索树,使用递归+数组储存实现
public static  boolean checkBST2(TreeNode head){
    boolean flag=true;
    List<TreeNode> list = new LinkedList<>();
    process(head,list);
    //遍历判断数组，判断是否是升序的.
    for (int i = 0; i < list.size(); i++) {
        if(list.get(i).value>=list.get(i+1).value){
            flag=false;
        }
    }
    return flag;
}
//递归将中序遍历数据存在数组中
public static void process(TreeNode head,List<TreeNode> inOrderList){
    if(head ==null){
        return;
    }
    process(head.leftChild,inOrderList);
    inOrderList.add(head);
    process(head.rightChild,inOrderList);
}
```

非递归的方式

```java
//使用非递归的方式将
public static boolean checkBST3(TreeNode head) {
    if (head != null) {
        int pre=Integer.MIN_VALUE;
        Stack<TreeNode> stack = new Stack<>();
        while (head != null || !stack.isEmpty()) {
            if (head != null) {
                stack.push(head);
                head = head.leftChild;
            } else {
                head = stack.pop();
                //中间是中序遍历的时候，更改代码实现逻辑
                if(head.value<=preValue){
                    return false;
                }else {
                    preValue=head.value;
                }
                head = head.rightChild;
            }
        }
    }
    return true;
}
```

6.判断一颗二叉树是否是一颗完全二叉树

使用层序遍历，满足2个条件1.若出现有右孩子无左孩子的情况直接返回false.2.在1的条件下若出现只有一个孩子，但它后面出现非叶子结点的情况下返回false.

```java
//判断是否是完全二叉树
public static boolean checkCBT(TreeNode head){
    if(head!=null){
        boolean flag=false;
        Queue<TreeNode> queue =new LinkedList<TreeNode>();
        queue.add(head);
        while(!queue.isEmpty()){
            head=queue.poll();
            if(head.leftChild==null&& head.rightChild!=null) {
                return false;
            }
            if(head.rightChild==null){
                flag=true;
            }
            if(flag && (head.leftChild!=null || head.rightChild!=null)){
                return false;
            }
            if(head.leftChild!=null){
                head=head.leftChild;
            }
            if(head.rightChild!=null){
                head=head.rightChild;
            }
        }
        return false;//循环结束仍然接受住考验则返回true
    }
    return true;//root为null直接返回true
}
```

7.判断一颗二叉树是否是满二叉树

树形dp套路

```java
//判断是否为满二叉树

public static boolean checkFBT(TreeNode head){
    if(head==null){
        return true;
    }
    Info info = process(head);
    if(info.nodes ==1<<info.height-1){
        return true;
    }
    return false;
};
public static Info process(TreeNode head){
    //别忘记这一行代码,是递归结束的必要条件
    if(head==null){
        return new Info(0,0);
    }
    Info leftInfo=process(head.leftChild);
    Info rightInfo=process(head.rightChild);
    int h=Math.max(leftInfo.height,rightInfo.height)+1;
    int nodes=leftInfo.nodes+rightInfo.nodes+1;
    return new Info(h,nodes);
}
class Info{
    int height;
    int nodes;
    public Info(int h,int nodes){
        this.height=h;
        this.nodes=nodes;
    }
```

8.判断一颗二叉树是否是平衡二叉树

9.寻找两个结点的最低公共祖先结点

```java
//寻找两个结点的最低公共祖先结点,使用哈希表
public static TreeNode lowestCommonAncestor(TreeNode head,TreeNode o1,TreeNode o2){
    HashMap<TreeNode, TreeNode> fatherMap = new HashMap<>();
    process3(head,fatherMap);
    HashSet<TreeNode> set = new HashSet<>();
    TreeNode cur=o1;
    //在cur不为头结点的情况下让o1向上穿,循环结束后除了头结点head均放入了set
    while(cur!=fatherMap.get(cur)){
        set.add(cur);
        cur=fatherMap.get(cur);
    }
    set.add(head);
    cur=o2;
    //cur指向o2，不断变成自己的父节点,每一次变都会判断其是否在set中存在,若循环结束仍然不存在,说明头结点是最低公共祖先
    while(cur!=fatherMap.get(cur)){
        if(set.contains(cur)){
            return cur;
        }
        cur=fatherMap.get(cur);
    }
    return head;
}
public static void process3(TreeNode head,HashMap<TreeNode,TreeNode> fatherMap){
    if(head==null){//basecase
        return;
    }
    fatherMap.put(head.leftChild,head);
    fatherMap.put(head.rightChild,head);
    process3(head.leftChild,fatherMap);
    process3(head.rightChild,fatherMap);
}
```



```java
//寻找两个结点的最低公共祖先,使用递归动态判断
public static TreeNode lowestCommonAncestor2(TreeNode head,TreeNode o1,TreeNode o2){
    //base case
    if(head==null||head==o1||head==o2){
        return head;
    }
    //在左树上寻找
    TreeNode left=lowestCommonAncestor2(head.leftChild,o1,o2);
    TreeNode right=lowestCommonAncestor2(head.rightChild,o1,o2);
    if(left==null&&right==null){
        return head;
    }
    //左右有一个不为空的情况返回不为空的那一个()
    return left!=null?left:right;
    
}
```

寻找一个结点的后继结点,假设结点中有parent属性

![image-20220517182400062](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220517182400062.png)



二叉树的序列化，反序列化

序列化

```java
//递归实现二叉树的序列化
public static String serialByPre(TreeNode head){
    if(head==null){
        return "#_";
    }
    String res=head.value+"_";
    res+=serialByPre(head.leftChild);
    res+=serialByPre(head.rightChild);
    return res;
}
```

![image-20220517182544183](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220517182544183.png)



反序列化

```java
//层序遍历实现二叉树的反序列化
public static TreeNode reconByPreString(String preStr){
    String[]values=preStr.split(",");
    Queue<String> queue = new LinkedList<>();
    for (int i = 0; i < values.length; i++) {
        queue.add(values[i]);
    }
    return reconPreOrder(queue);
}
public static TreeNode reconPreOrder(Queue<String> queue){
    String value=queue.poll();
    if(value.equals("#")){
        return null;
    }
    TreeNode head=new TreeNode(Integer.parseInt(value));
    head.leftChild=reconPreOrder(queue);
    head.rightChild=reconPreOrder(queue);
    return head;
}
```

微软原题

打印折痕

```java
//微软原题,折纸问题，抽象为一颗二叉树
public static void printProcess(int n){
    process(0,n,true);
}
public static void process(int i,int n,boolean down){
    if(i>n){
        return;
    }
    process(i+1,n,true);
    System.out.println(down?"凹":"凸");
    process(i+1,n,false);
}
```

### 图

图的基本结构

```java
import java.util.HashMap;
import java.util.HashSet;

public class Graph {
    HashMap<Integer,Node>Nodes;
    HashSet<edge>edges;

    public Graph() {
    }
}
```

点的基本结构

```java
import java.util.ArrayList;

public class Node {
    public int value;//值
    public int in;//入度
    public int out;//出度
    public ArrayList<Node>nexts;//下一个点
    public ArrayList<edge>edges;//边

    public Node(int value, int in, int out) {
        this.value = value;
        this.in = in;
        this.out = out;
    }
}
```

边的基本结构

```java
public class edge {
    int weight;//权重
    Node from;//从某个点来
    Node to;//到某个点去

    public edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

将其他形式的图转化为我们熟悉的图



图的广度优先遍历(bfs)

使用queue实现,使用一个hashset注册机制，维护每一个结点只在queue中出现一次

```java
//宽度优先遍历(队列实现,set维护)
public static void bfs(Node node){
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();
    queue.add(node);
    set.add(node);
    while(!queue.isEmpty()){
        //开始统一处理
        Node cur=queue.poll();
        //处理cur
        System.out.println(cur.value);
        //将所有宽度放入队列最后统一处理
        for(Node next:cur.nexts){
            if(!set.contains(next)){
                queue.add(next);
                set.add(next);
            }
        }
    }
}
```



图的深度优先遍历 (dfs)

```java
public static void dfs(Node node){
    if (node==null){
        return;
    }
    Stack<Node> stack = new Stack<>();
    HashSet<Node> set = new HashSet<>();//新建一个hashset动态维护保证每一个结点仅出现一次
    Node cur=node;
    stack.push(cur);
    set.add(cur);
    System.out.println(cur);
    while(!stack.isEmpty()){
        cur=stack.pop();
        for (Node next:cur.nexts) {
            if (!set.contains(next)) {
                stack.push(cur);
                stack.push(next);
                set.add(next) ;
                //处理这个邻居
                System.out.println(next.value);
                //把邻居加进去后就不看A后面的结点了
                break;
            }
        }
    }
}
```

图的拓扑排序

概念:

在图论中，**拓扑排序（Topological Sorting**）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

1. 每个顶点出现且只出现一次。
2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。

方法:

如果图中一个结点的入度为零，则将其本身以及对后继节点的影响擦去，并将其放入数组之中.

实现

```java
//拓扑排序
public static List<Node> sortedTopology(Graph graph) {
    HashMap<Node, Integer> inMap = new HashMap<>();//储存每一个节点的入度
    Queue<Node> zeroQueue = new LinkedList<>();//储存每一个入度为零的结点
    //将每一个结点的入度存入hashmap
    for(Node node:graph.Nodes.values()){
            inMap.put(node,node.in);
            if(node.in==0){
                zeroQueue.add(node);
            }
    }
    //将拓扑排序的结果加入到结果集中
    LinkedList<Node> result = new LinkedList<>();
    while(!zeroQueue.isEmpty()){
        Node cur=zeroQueue.poll();
        result.add(cur);
        //擦除其对后继节点的影响
        for(Node next:cur.nexts) {
            inMap.put(next, cur.in - 1);
            if(next.in==0){
                zeroQueue.add(next);
            }
        }
    }
    return result;
}
```



kruskal算法(k算法)

要求无向图

生成最小生成树

保证连通性的情况下让权重总和最小

基于并查集的贪心算法

依次把最小的边加上看有没有形成环，若会形成环则不加

如何考察加上一个边的时候会不会形成环?使用并查集实现某种机制实现集合查询和集合合并。

并查集后面讲(实现复杂度为常数级别)，这里我们实现一个简单的和并查集有相似功能的集合

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class MySets {
    //hashMap记录每一个结点的集合
    public HashMap<Node, List<Node>> setMap;
    public MySets(List<Node> nodes){
        for(Node cur:nodes){
            List<Node> set = new ArrayList<>();
            set.add(cur);
            setMap.put(cur,set);
        }
    }
    //判断2个点是否在同一个集合中
    public boolean isSameSet(Node from,Node to){
        List<Node> fromSet = setMap.get(from);
        List<Node> toSet = setMap.get(to);
        return fromSet==toSet;
    }
    //把from的集合和to的集合合并为一个集合
    public void union(Node from,Node to){
        List<Node> fromSet = setMap.get(from);
        List<Node> toSet = setMap.get(to);
        //把to中的所有Node加入到fromset,把所有结点在map中的记录指向fromset
        for(Node cur:toSet){
            fromSet.add(cur);
            setMap.put(cur,fromSet);
        }
    }
}
```

















prim算法(p算法)

要求无向图

生成最小生成树

保证连通性的情况下让权重总和最小

### 前缀树

TrieNode结构

```java
public class TrieNode {
    public int pass;//记录前缀为该结点的字符串结尾的字符串数目
    public int end;//记录以该节点作为结尾的字符串数目
    public TrieNode[] nexts;//记录该结点的下一个结点
    public TrieNode(){
        pass=0;
        end=0;
        nexts=new TrieNode[26];//储存26个字母
    }

}
```

Trie结构

```java
import java.util.HashMap;

public class Trie {
    public TrieNode root;
    public Trie(){
        root=new TrieNode();
    }
    //插入一个字符串
    public void insert(String word){
        if(word==null){
            return;
        }
        char[] chars = word.toCharArray();
        TrieNode node=root;//引入一个临时的node结点
        for(char chr:chars){

            int index=chr-'a';
            if(node.nexts[index]==null) {
                node.nexts[index] = new TrieNode();
            }
            node=node.nexts[index];
            node.pass++;
        }
        node.end++;//循环结束后说明来到了字符串的结尾
    }
    //删除一个字符串
    public void delete(String word){
        if(word==null||search(word)==0){
            return;
        }
        char[] chars = word.toCharArray();
        TrieNode node=root;
        for(char chr:chars){
            node.pass-=1;
            int index=chr-'a';
            node=node.nexts[index];
        }
        node.end--;//遍历结束后来到了结尾
        if(node.pass==0){
            node.nexts=null;
        }//注意，需要把end==0的next给gc调

    }
    //查询以一个字符串为前缀的单词的个数
    public int prefixNumber(String pre){
        if(pre==null){
            return 0;
        }
        char[]chars=pre.toCharArray();
        int num=0;
        TrieNode node=root;
        for(char chr :chars){
            int index=chr-'a';
            node=node.nexts[index];
        }
        num=node.pass;//循环结束后说明来到了结尾
        return num;
    }
    //查询一个字符串的个数
    public int search(String word){
        if(word==null){
            return 0;
        }
        char[]chars=word.toCharArray();
        int num=0;
        TrieNode node=root;
        for(char chr :chars){
            int index=chr-'a';
            node=node.nexts[index];
        }
        //循环结束后说明来到了结尾
        num=node.end;
        return num;
    }

}

```

### 贪心算法

贪心算法最常用的方式:

1.构造一个比较器对数组进行排序

注意:排序策略必须要有传递性，否则无意义

2.构造堆结构

题目

1.一块金条切成两块,是需要花费与长度一样的铜板的,比如长度为20的金条,不管切成长度多大的两半，都要花费20个金条。

一群人想整分整块金条，怎么分最省铜板?输入一个数组，返回分割的最小代价.

例如:给定数组[10,20,30]，代表一共三个人，整块金条的长度为10+20+30=60.把金条分成10,20,30三个部分

经典哈夫曼编码问题

思路:

我们逆向思维，让最后分割后的金条，任意两两组合，设置一个贪心策略让两两组合的金条总长度最小.





2.会议问题:

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目的开始的时间和结束的时间(给你一个数组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行宣讲的场次最多，返回这个最多的宣讲场次

思路:我们先想出一个贪心策略:哪个会议的结束时间早就优先安排谁

```java
public static class program{
    public int start;
    public int end;
    public program(int start, int end) {
        this.start = start;
        this.end = end;
    }
}
public static class ProgramComparator implements Comparator<program>{
    @Override
    public int compare(program o1, program o2) {
        return o1.end -o2.end;//让会议结束时间最早的放在数组前面
    }
}
//timePoint表示会议开始的时间
public static int bestArrange(program[]programs,int timePoint){
    Arrays.sort(programs,new ProgramComparator());
    int result=0;//代表安排的会议数目
    for(program prg :programs){
        //如果时间点比会议开始时间早就安排它,并让时间点推后
        if(timePoint<prg.start){
            result++;
            timePoint=prg.end;
        }
        //否则就直接跳过它直接什么都不写
    }
    return result;
}
```

3.字典序问题

输入一个数组，放的是很多个字符串，请你将这些字符串拼接为一个字符串并且该字符串的字典序比其它字符串的字典序小.

第一种贪心策略:

把所有的字符串按字典序进行排序,然后从前到后进行拼接:

举出反例不对如"b"和"ba"输出:"bba"预期"bab"

第二种贪心策略:

将两个参数字符串进行拼接，若ba<ab，则把b放在前面，否则把a放在前面.

实现:java中有compareTo方法，比较的就是两个字符串的字典序大小

```java
public static class Mycomparator implements Comparator<String>{
    @Override
    public int compare(String o1, String o2) {
        return  (o1+o2).compareTo(o2+o1);
    }
}
public static String lowestLexicography(String[]strs){
    Arrays.sort(strs,new Mycomparator());
    String ans="";
    for (String str :strs){
        ans+=str;
    }
    return ans;
}
```

4.公司创业:

输入正数数组costs

正数数组profiles

正数k

正数m

含义:

costs[i]表示i号项目的花费

profile[i]表示i号项目的利润

k表示你只能串行的执行k个项目

m表示你初始的资金

返回最大利润数

思路:

用一个小根堆表示被锁住的项目，堆顶表示需要资金最小的项目

用一个大根堆表示解锁的项目，堆顶表示利润最大的项目

3.



### 补充:n皇后问题



### 哈希函数与哈希表

### KMP

### Manacher算法
